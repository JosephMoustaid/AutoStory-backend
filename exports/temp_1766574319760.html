<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Arial', sans-serif;
      overflow: hidden;
    }
    #canvas {
      display: block;
    }
    .fade-in {
      animation: fadeIn 1s ease-in;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="1920" height="1080"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const chapters = [{"title":"Lightning in a Bottle","content":"With tri-motor all-wheel drive delivering 1,020 horsepower, the Model S Plaid accelerates from 0-60 mph in under 2 seconds. This isn't just fastâ€”it's a physics-defying experience that redefines what an electric vehicle can achieve."},{"title":"Cutting-Edge Technology","content":"A 17-inch cinematic display serves as your command center, controlling everything from climate to entertainment. With over-the-air updates, your vehicle constantly evolves, gaining new features and improvements while you sleep."},{"title":"Sustainable Luxury","content":"Premium vegan leather interior, HEPA air filtration, and a 396-mile range prove that luxury and sustainability can coexist. This is the future of automotive excellence, available today."}];
    
    let currentScene = 0;
    const scenes = [
      {
        type: 'title',
        title: "The Future of Performance",
        subtitle: "Tesla Model S Plaid - Redefining Electric Excellence",
        duration: 3000
      },
      {
        type: 'info',
        title: '2024 Tesla Model S Plaid',
        subtitle: 'Type: Electric Sedan',
        duration: 3000
      },
      ...chapters.map((ch, i) => ({
        type: 'chapter',
        title: ch.title,
        content: ch.content,
        duration: 5000,
        index: i
      }))
    ];

    // Animation utilities
    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function drawGradientBackground(colors, time = 0) {
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      const offset = Math.sin(time / 1000) * 0.1;
      gradient.addColorStop(0, colors[0]);
      gradient.addColorStop(0.5 + offset, colors[1]);
      gradient.addColorStop(1, colors[2]);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawText(text, x, y, fontSize, color, alpha = 1, progress = 1) {
      ctx.save();
      ctx.globalAlpha = alpha * progress;
      ctx.fillStyle = color;
      ctx.font = `bold ${fontSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Add text shadow for depth
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 20;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 10;
      
      const yOffset = (1 - easeOutCubic(progress)) * 50;
      ctx.fillText(text, x, y - yOffset);
      ctx.restore();
    }

    function wrapText(text, maxWidth) {
      const words = text.split(' ');
      const lines = [];
      let currentLine = '';

      for (let word of words) {
        const testLine = currentLine + word + ' ';
        const metrics = ctx.measureText(testLine);
        
        if (metrics.width > maxWidth && currentLine !== '') {
          lines.push(currentLine);
          currentLine = word + ' ';
        } else {
          currentLine = testLine;
        }
      }
      lines.push(currentLine);
      return lines;
    }

    function drawMultilineText(text, x, y, fontSize, color, alpha, progress, maxWidth) {
      ctx.font = `${fontSize}px Arial`;
      const lines = wrapText(text, maxWidth);
      const lineHeight = fontSize * 1.4;
      const startY = y - (lines.length * lineHeight) / 2;

      lines.forEach((line, i) => {
        const lineProgress = Math.max(0, Math.min(1, progress * 2 - i * 0.2));
        drawText(line.trim(), x, startY + i * lineHeight, fontSize, color, alpha, lineProgress);
      });
    }

    function drawScene(scene, progress) {
      const colors = scene.index % 2 === 0 
        ? ['#1a1a2e', '#16213e', '#0f3460']
        : ['#16213e', '#0f3460', '#1a1a2e'];
      
      drawGradientBackground(colors, Date.now());

      // Add animated particles
      drawParticles(progress);

      const centerX = canvas.width / 2;
      const titleY = 300;
      const subtitleY = 400;
      const contentY = 600;

      if (scene.type === 'title') {
        drawText(scene.title, centerX, titleY, 80, '#ffffff', 1, progress);
        if (scene.subtitle) {
          drawText(scene.subtitle, centerX, subtitleY, 40, '#aaaaaa', 0.9, Math.max(0, progress - 0.2));
        }
      } else if (scene.type === 'info') {
        drawText(scene.title, centerX, titleY, 70, '#ffffff', 1, progress);
        drawText(scene.subtitle, centerX, subtitleY, 35, '#aaaaaa', 0.9, Math.max(0, progress - 0.2));
      } else if (scene.type === 'chapter') {
        drawText(scene.title, centerX, 250, 60, '#ffffff', 1, progress);
        drawMultilineText(scene.content, centerX, contentY, 32, '#eeeeee', 0.95, Math.max(0, progress - 0.3), 1400);
      }
    }

    // Particle system for visual effects
    const particles = Array.from({ length: 50 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      radius: Math.random() * 2 + 1,
      alpha: Math.random() * 0.5
    }));

    function drawParticles(sceneProgress) {
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        
        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha * sceneProgress})`;
        ctx.fill();
      });
    }

    // Animation loop
    let startTime = Date.now();
    let sceneStartTime = startTime;

    function animate() {
      const now = Date.now();
      const elapsed = now - sceneStartTime;
      const scene = scenes[currentScene];
      const progress = Math.min(1, elapsed / 1000); // 1 second fade in

      drawScene(scene, progress);

      if (elapsed >= scene.duration) {
        currentScene++;
        sceneStartTime = now;
        
        if (currentScene >= scenes.length) {
          // Animation complete
          return;
        }
      }

      requestAnimationFrame(animate);
    }

    // Start animation
    animate();
  </script>
</body>
</html>