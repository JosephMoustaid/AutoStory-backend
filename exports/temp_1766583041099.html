<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      font-family: 'Helvetica Neue', Arial, sans-serif;
      overflow: hidden;
    }
    #canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas" width="1920" height="1080"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;
    const chapters = [{"title":"Lightning in a Bottle","content":"With tri-motor all-wheel drive delivering 1,020 horsepower, the Model S Plaid accelerates from 0-60 mph in under 2 seconds. This isn't just fastâ€”it's a physics-defying experience that redefines what an electric vehicle can achieve."},{"title":"Cutting-Edge Technology","content":"A 17-inch cinematic display serves as your command center, controlling everything from climate to entertainment. With over-the-air updates, your vehicle constantly evolves, gaining new features and improvements while you sleep."},{"title":"Sustainable Luxury","content":"Premium vegan leather interior, HEPA air filtration, and a 396-mile range prove that luxury and sustainability can coexist. This is the future of automotive excellence, available today."}];
    
    let currentScene = 0;
    const scenes = [
      { type: 'opening', duration: 4000 },
      { type: 'title', title: "The Future of Performance", subtitle: "Tesla Model S Plaid - Redefining Electric Excellence", duration: 4500 },
      { type: 'reveal', title: '2024 Tesla Model S Plaid', subtitle: 'Electric Sedan', duration: 4000 },
      ...chapters.map((ch, i) => ({ type: 'chapter', title: ch.title, content: ch.content, duration: 6000, index: i })),
      { type: 'closing', duration: 3000 }
    ];

    // CINEMATIC EASING FUNCTIONS
    const easing = {
      easeOutCubic: t => 1 - Math.pow(1 - t, 3),
      easeInOutQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
      easeOutElastic: t => {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
      }
    };

    // PARTICLE SYSTEM FOR PREMIUM EFFECTS
    class ParticleSystem {
      constructor(count = 100) {
        this.particles = Array.from({ length: count }, () => ({
          x: Math.random() * W,
          y: Math.random() * H,
          vx: (Math.random() - 0.5) * 0.8,
          vy: (Math.random() - 0.5) * 0.8,
          size: Math.random() * 3 + 0.5,
          alpha: Math.random() * 0.6 + 0.2,
          speed: Math.random() * 0.5 + 0.3
        }));
      }
      
      update() {
        this.particles.forEach(p => {
          p.x += p.vx * p.speed;
          p.y += p.vy * p.speed;
          if (p.x < 0 || p.x > W) p.vx *= -1;
          if (p.y < 0 || p.y > H) p.vy *= -1;
        });
      }
      
      draw(progress = 1) {
        this.particles.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha * progress * 0.4})`;
          ctx.fill();
          
          // Connect nearby particles
          this.particles.forEach(p2 => {
            const dx = p2.x - p.x;
            const dy = p2.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 100) {
              ctx.strokeStyle = `rgba(100, 200, 255, ${(1 - dist/100) * 0.15 * progress})`;
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          });
        });
      }
    }
    
    const particles = new ParticleSystem(80);

    // CINEMATIC GRADIENT BACKGROUNDS
    function drawCinematicBackground(scene, progress, time) {
      const gradients = {
        dark: ['#0a0a0a', '#1a1a2e', '#16213e'],
        blue: ['#0f2027', '#203a43', '#2c5364'],
        purple: ['#2b1055', '#7597de', '#16213e'],
        gold: ['#1a1a1a', '#4a3c2e', '#2e2416']
      };
      
      const colors = scene.index !== undefined && scene.index % 2 === 0 ? gradients.purple : gradients.blue;
      
      const gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W * 0.8);
      gradient.addColorStop(0, colors[0]);
      gradient.addColorStop(0.5 + Math.sin(time / 2000) * 0.1, colors[1]);
      gradient.addColorStop(1, colors[2]);
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
      
      // Add vignette effect
      const vignette = ctx.createRadialGradient(W/2, H/2, 200, W/2, H/2, W * 0.7);
      vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
      vignette.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, W, H);
    }

    // PROFESSIONAL TEXT RENDERING
    function drawCinematicText(text, x, y, size, color, alpha, progress, options = {}) {
      ctx.save();
      ctx.globalAlpha = alpha * progress;
      
      const weight = options.bold ? 'bold' : 'normal';
      const family = options.serif ? 'Georgia, serif' : 'Helvetica Neue, Arial, sans-serif';
      ctx.font = `${weight} ${size}px ${family}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Cinematic text shadow
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 30;
      ctx.shadowOffsetY = 15;
      
      // Glow effect
      if (options.glow) {
        ctx.shadowColor = color;
        ctx.shadowBlur = 50;
      }
      
      const yOffset = (1 - easing.easeOutCubic(progress)) * 80;
      const xOffset = options.slideIn ? (1 - easing.easeOutCubic(progress)) * 200 : 0;
      
      ctx.fillStyle = color;
      ctx.fillText(text, x + xOffset, y - yOffset);
      ctx.restore();
    }

    function wrapText(text, maxWidth, fontSize) {
      ctx.font = `${fontSize}px Helvetica Neue, Arial`;
      const words = text.split(' ');
      const lines = [];
      let currentLine = '';
      
      words.forEach(word => {
        const testLine = currentLine + word + ' ';
        if (ctx.measureText(testLine).width > maxWidth && currentLine) {
          lines.push(currentLine.trim());
          currentLine = word + ' ';
        } else {
          currentLine = testLine;
        }
      });
      lines.push(currentLine.trim());
      return lines;
    }

    function drawMultilineText(text, x, y, fontSize, color, alpha, progress, maxWidth) {
      const lines = wrapText(text, maxWidth, fontSize);
      const lineHeight = fontSize * 1.6;
      const startY = y - (lines.length * lineHeight) / 2;
      
      lines.forEach((line, i) => {
        const lineProgress = Math.max(0, Math.min(1, progress * 1.5 - i * 0.15));
        drawCinematicText(line, x, startY + i * lineHeight, fontSize, color, alpha, lineProgress);
      });
    }

    // CINEMATIC SCENE TRANSITIONS
    function drawScene(scene, progress, time) {
      drawCinematicBackground(scene, progress, time);
      particles.update();
      particles.draw(progress);
      
      const centerX = W / 2;
      const fadeIn = easing.easeOutCubic(Math.min(progress * 1.5, 1));
      const fadeOut = scene.duration ? Math.min(1, ((Date.now() - sceneStartTime) / (scene.duration - 500))) : 1;
      const alpha = Math.min(fadeIn, 2 - fadeOut);
      
      if (scene.type === 'opening') {
        // Dramatic opening with light rays
        ctx.save();
        for (let i = 0; i < 12; i++) {
          ctx.save();
          ctx.translate(centerX, H/2);
          ctx.rotate((i * Math.PI / 6) + time / 1000);
          const grad = ctx.createLinearGradient(0, -H, 0, H);
          grad.addColorStop(0, 'rgba(100, 200, 255, 0)');
          grad.addColorStop(0.5, `rgba(100, 200, 255, ${0.1 * progress})`);
          grad.addColorStop(1, 'rgba(100, 200, 255, 0)');
          ctx.fillStyle = grad;
          ctx.fillRect(-50, -H, 100, H * 2);
          ctx.restore();
        }
        ctx.restore();
        
        drawCinematicText('AUTOSTORY', centerX, H/2, 120, '#ffffff', 1, fadeIn, { glow: true, bold: true });
        drawCinematicText('Vehicle Storytelling Experience', centerX, H/2 + 100, 36, '#64c8ff', 0.9, Math.max(0, fadeIn - 0.3));
        
      } else if (scene.type === 'title') {
        drawCinematicText(scene.title, centerX, H/2 - 50, 90, '#ffffff', 1, fadeIn, { bold: true });
        if (scene.subtitle) {
          drawCinematicText(scene.subtitle, centerX, H/2 + 80, 42, '#aaccff', 0.95, Math.max(0, fadeIn - 0.2));
        }
        
      } else if (scene.type === 'reveal') {
        // Specs reveal with animated lines
        const lineProgress = easing.easeOutCubic(Math.max(0, fadeIn - 0.2));
        ctx.strokeStyle = `rgba(100, 200, 255, ${0.6 * lineProgress})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(W/2 - 400 * lineProgress, H/2 - 100);
        ctx.lineTo(W/2 + 400 * lineProgress, H/2 - 100);
        ctx.stroke();
        
        drawCinematicText(scene.title, centerX, H/2 - 20, 75, '#ffffff', 1, fadeIn, { bold: true });
        drawCinematicText(scene.subtitle, centerX, H/2 + 70, 38, '#88aacc', 0.9, Math.max(0, fadeIn - 0.3));
        
      } else if (scene.type === 'chapter') {
        drawCinematicText(scene.title, centerX, 280, 68, '#ffffff', 1, fadeIn, { bold: true });
        
        // Accent line
        const lineW = 300 * easing.easeOutElastic(Math.max(0, fadeIn - 0.2));
        ctx.fillStyle = '#64c8ff';
        ctx.fillRect(centerX - lineW/2, 360, lineW, 3);
        
        drawMultilineText(scene.content, centerX, 600, 34, '#e0e0e0', 0.95, Math.max(0, fadeIn - 0.3), 1500);
        
      } else if (scene.type === 'closing') {
        drawCinematicText('POWERED BY AUTOSTORY', centerX, H/2, 60, '#ffffff', 1, fadeIn, { bold: true });
        drawCinematicText('AI-Driven Vehicle Narratives', centerX, H/2 + 80, 32, '#64c8ff', 0.8, Math.max(0, fadeIn - 0.2));
      }
    }

    // ANIMATION LOOP
    let sceneStartTime = Date.now();
    
    function animate() {
      const now = Date.now();
      const elapsed = now - sceneStartTime;
      const scene = scenes[currentScene];
      const progress = Math.min(1, elapsed / 1000);
      
      drawScene(scene, progress, now);
      
      if (elapsed >= scene.duration) {
        currentScene++;
        sceneStartTime = now;
        if (currentScene >= scenes.length) return; // Complete
      }
      
      requestAnimationFrame(animate);
    }
    
    animate();
  </script>
</body>
</html>